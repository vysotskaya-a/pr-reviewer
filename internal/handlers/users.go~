package handlers

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"pr-reviewer/internal/models"
	"pr-reviewer/internal/store"

	"github.com/go-chi/chi/v5"
	"go.uber.org/zap"
)

type Handlers struct {
	store *store.Store
	log   *zap.Logger
}

func NewHandlers(s *store.Store, log *zap.Logger) *Handlers {
	return &Handlers{store: s, log: log}
}

func (h *Handlers) CreateUser(w http.ResponseWriter, r *http.Request) {
	var in struct {
		Username    string  `json:"username"`
		DisplayName *string `json:"display_name"`
		TeamName    *string `json:"team_name"`
	}
	if err := json.NewDecoder(r.Body).Decode(&in); err != nil {
		h.log.Error("decode create user", zap.Error(err))
		http.Error(w, "invalid body", http.StatusBadRequest)
		return
	}

	ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
	defer cancel()

	var user models.User
	query := `INSERT INTO users (username, display_name, team_name) VALUES ($1, $2, $3) RETURNING user_id, username, display_name, is_active, team_name, created_at`
	row := h.store.Pool().QueryRow(ctx, query, in.Username, in.DisplayName, in.TeamName)
	if err := row.Scan(&user.UserID, &user.Username, &user.DisplayName, &user.IsActive, &user.TeamName, &user.CreatedAt); err != nil {
		h.log.Error("insert user", zap.Error(err))
		http.Error(w, "db error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	_ = json.NewEncoder(w).Encode(user)
}

func (h *Handlers) ListUsers(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
	defer cancel()

	rows, err := h.store.Pool().Query(ctx, `SELECT user_id, username, display_name, is_active, team_name, created_at FROM users`)
	if err != nil {
		h.log.Error("select users", zap.Error(err))
		http.Error(w, "db error", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	users := make([]models.User, 0)
	for rows.Next() {
		var u models.User
		if err := rows.Scan(&u.UserID, &u.Username, &u.DisplayName, &u.IsActive, &u.TeamName, &u.CreatedAt); err != nil {
			h.log.Error("scan user", zap.Error(err))
			http.Error(w, "db error", http.StatusInternalServerError)
			return
		}
		users = append(users, u)
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(users)
}

func (h *Handlers) GetUser(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
	defer cancel()

	var u models.User
	row := h.store.Pool().QueryRow(ctx, `SELECT user_id, username, display_name, is_active, team_name, created_at FROM users WHERE user_id = $1`, id)
	if err := row.Scan(&u.UserID, &u.Username, &u.DisplayName, &u.IsActive, &u.TeamName, &u.CreatedAt); err != nil {
		h.log.Error("get user", zap.Error(err))
		http.Error(w, "not found", http.StatusNotFound)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(u)
}

func (h *Handlers) UpdateUser(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	var in struct {
		DisplayName *string `json:"display_name"`
		IsActive    *bool   `json:"is_active"`
		TeamName    *string `json:"team_name"`
	}
	if err := json.NewDecoder(r.Body).Decode(&in); err != nil {
		h.log.Error("decode update user", zap.Error(err))
		http.Error(w, "invalid body", http.StatusBadRequest)
		return
	}

	ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
	defer cancel()

	// simple partial update
	_, err := h.store.Pool().Exec(ctx, `UPDATE users SET display_name = COALESCE($1, display_name), is_active = COALESCE($2, is_active), team_name = COALESCE($3, team_name) WHERE user_id = $4`, in.DisplayName, in.IsActive, in.TeamName, id)
	if err != nil {
		h.log.Error("update user", zap.Error(err))
		http.Error(w, "db error", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

func (h *Handlers) DeleteUser(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
	defer cancel()

	result, err := h.store.Pool().Exec(ctx, `DELETE FROM users WHERE user_id = $1`, id)
	if err != nil {
		h.log.Error("delete user", zap.Error(err))
		http.Error(w, "db error", http.StatusInternalServerError)
		return
	}

	if result.RowsAffected() == 0 {
		http.Error(w, "user not found", http.StatusNotFound)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}
