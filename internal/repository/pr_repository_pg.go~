package repository

import (
	"context"
	"time"

	"pr-reviewer/internal/models"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

type prRepoPG struct {
	p *pgxpool.Pool
}

func NewPRRepositoryPG(p *pgxpool.Pool) PRRepository {
	return &prRepoPG{p: p}
}

func (r *prRepoPG) Create(ctx context.Context, pr *models.PullRequest) error {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	query := `
		INSERT INTO prs (pull_request_id, pull_request_name, author_id, team_name, status)
		VALUES ($1, $2, $3, $4, 'OPEN')
	`
	_, err := r.p.Exec(ctx, query,
		pr.PullRequestID,
		pr.PullRequestName,
		pr.AuthorID,
		pr.TeamName,
	)
	return err
}

func (r *prRepoPG) GetByID(ctx context.Context, id string) (*models.PullRequest, error) {
	ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
	defer cancel()

	query := `
		SELECT pull_request_id, pull_request_name, author_id, team_name, status, created_at, merged_at
		FROM prs WHERE pull_request_id = $1
	`
	var pr models.PullRequest
	err := r.p.QueryRow(ctx, query, id).Scan(
		&pr.PullRequestID,
		&pr.PullRequestName,
		&pr.AuthorID,
		&pr.TeamName,
		&pr.Status,
		&pr.CreatedAt,
		&pr.MergedAt,
	)
	if err == pgx.ErrNoRows {
		return nil, ErrPRNotFound
	}
	if err != nil {
		return nil, err
	}

	return &pr, nil
}

func (r *prRepoPG) ListByReviewer(ctx context.Context, reviewerID string) ([]models.PullRequest, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	query := `
		SELECT p.pull_request_id, p.pull_request_name, p.author_id, p.team_name, p.status, p.created_at, p.merged_at
		FROM prs p
		JOIN pr_reviewers r ON p.pull_request_id = r.pull_request_id
		WHERE r.reviewer_id = $1
	`
	rows, err := r.p.Query(ctx, query, reviewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var list []models.PullRequest
	for rows.Next() {
		var pr models.PullRequest
		err := rows.Scan(
			&pr.PullRequestID,
			&pr.PullRequestName,
			&pr.AuthorID,
			&pr.TeamName,
			&pr.Status,
			&pr.CreatedAt,
			&pr.MergedAt,
		)
		if err != nil {
			return nil, err
		}
		list = append(list, pr)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return list, nil
}

func (r *prRepoPG) SetMerged(ctx context.Context, id string) error {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	query := `
		UPDATE prs SET status = 'MERGED', merged_at = NOW()
		WHERE pull_request_id = $1 AND status != 'MERGED'
	`
	result, err := r.p.Exec(ctx, query, id)
	if err != nil {
		return err
	}

	rowsAffected := result.RowsAffected()
	if rowsAffected == 0 {
		// Проверяем, существует ли PR вообще
		pr, err := r.GetByID(ctx, id)
		if err != nil {
			return err
		}
		if pr.Status == "MERGED" {
			return ErrPRAlreadyMerged
		}
		return ErrPRNotFound
	}

	return nil
}

func (r *prRepoPG) AddReviewer(ctx context.Context, prID string, reviewerID string) error {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	query := `
		INSERT INTO pr_reviewers (pull_request_id, reviewer_id)
		VALUES ($1, $2)
		ON CONFLICT (pull_request_id, reviewer_id) DO NOTHING
	`
	_, err := r.p.Exec(ctx, query, prID, reviewerID)
	return err
}

func (r *prRepoPG) RemoveReviewer(ctx context.Context, prID string, reviewerID string) error {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	query := `
		DELETE FROM pr_reviewers
		WHERE pull_request_id = $1 AND reviewer_id = $2
	`
	result, err := r.p.Exec(ctx, query, prID, reviewerID)
	if err != nil {
		return err
	}

	rowsAffected := result.RowsAffected()
	if rowsAffected == 0 {
		return ErrReviewerNotFound
	}

	return nil
}

func (r *prRepoPG) ListReviewers(ctx context.Context, prID string) ([]models.User, error) {
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	query := `
		SELECT u.user_id, u.username, u.display_name, u.is_active, u.team_name, u.created_at
		FROM pr_reviewers r 
		JOIN users u ON r.reviewer_id = u.user_id
		WHERE r.pull_request_id = $1
	`
	rows, err := r.p.Query(ctx, query, prID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var result []models.User
	for rows.Next() {
		var u models.User
		err := rows.Scan(
			&u.UserID,
			&u.Username,
			&u.DisplayName,
			&u.IsActive,
			&u.TeamName,
			&u.CreatedAt,
		)
		if err != nil {
			return nil, err
		}
		result = append(result, u)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return result, nil
}